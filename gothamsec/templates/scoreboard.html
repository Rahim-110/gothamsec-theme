{% extends "base.html" %}

{% block title %}Scoreboard - {{ get_config("ctf_name") }}{% endblock %}

{% block content %}
<div class="container">
    <!-- Hero Section -->
    <div class="hero" style="min-height: 25vh; padding: 2rem 0;">
        <div class="hero-content">
            <h1 class="hero-title">Scoreboard</h1>
            <p class="hero-subtitle">Real-time rankings. Who will claim the crown?</p>
        </div>
    </div>

    <!-- Stats Overview -->
    <div class="d-flex justify-center gap-3 mb-4" style="flex-wrap: wrap;">
        <div class="glass-panel text-center" style="padding: 1.5rem 2rem; min-width: 150px;">
            <div class="text-cyan" style="font-size: 2rem; font-weight: 700;" id="total-teams">--</div>
            <div class="text-muted">{{ 'Teams' if get_config('user_mode') == 'teams' else 'Players' }}</div>
        </div>
        <div class="glass-panel text-center" style="padding: 1.5rem 2rem; min-width: 150px;">
            <div class="text-purple" style="font-size: 2rem; font-weight: 700;" id="total-solves">--</div>
            <div class="text-muted">Total Solves</div>
        </div>
        <div class="glass-panel text-center" style="padding: 1.5rem 2rem; min-width: 150px;">
            <div class="text-cyan" style="font-size: 2rem; font-weight: 700;" id="total-challenges">--</div>
            <div class="text-muted">Challenges</div>
        </div>
    </div>

    <!-- Score Graph -->
    <div class="glass-panel mb-4">
        <h3 class="text-cyan mb-3" style="text-align: center;">Top 10 {{ 'Teams' if get_config('user_mode') == 'teams'
            else 'Players' }}</h3>
        <div id="score-graph" style="height: 400px; width: 100%;"></div>
    </div>

    <!-- Scoreboard Table -->
    <div class="glass-panel">
        <table class="scoreboard-table" style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr>
                    <th style="width: 100px; padding: 1rem; text-align: left;">Place</th>
                    <th style="padding: 1rem; text-align: left;">{{ 'Team' if get_config('user_mode') == 'teams' else
                        'Player' }}</th>
                    <th style="width: 150px; padding: 1rem; text-align: right;">Score</th>
                </tr>
            </thead>
            <tbody id="scoreboard-body">
                <!-- Rows loaded dynamically -->
            </tbody>
        </table>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

<script>
    (function () {
        const scoreboardBody = document.getElementById('scoreboard-body');
        const graphContainer = document.getElementById('score-graph');
        let standings = [];
        let scoreChart = null;

        // GothamSec color palette
        const chartColors = [
            '#00d9ff', '#b026ff', '#ff2a6d', '#05d9e8', '#ff6b35',
            '#ffd700', '#7b68ee', '#00ff7f', '#ff1493', '#1e90ff'
        ];

        async function fetchScoreboard() {
            try {
                const response = await fetch('/api/v1/scoreboard');

                if (!response.ok) {
                    throw new Error('Scoreboard API returned ' + response.status);
                }

                const data = await response.json();

                if (data.success && data.data) {
                    standings = data.data;
                    renderScoreboard();
                    updateStats();
                    fetchGraphData();
                } else {
                    scoreboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 2rem; color: #888;">No scoreboard data available</td></tr>';
                }
            } catch (error) {
                console.error('Error fetching scoreboard:', error);
                scoreboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 2rem; color: #888;">Failed to load scoreboard</td></tr>';
            }
        }

        async function fetchGraphData() {
            try {
                // Fetch top 10 with solve history
                const response = await fetch('/api/v1/scoreboard/top/10');
                if (!response.ok) {
                    console.log('Top 10 API not available');
                    return;
                }

                const data = await response.json();
                if (data.success && data.data && data.data.length > 0) {
                    renderGraph(data.data);
                }
            } catch (error) {
                console.error('Error fetching graph data:', error);
            }
        }

        function renderGraph(topTeams) {
            if (!topTeams || topTeams.length === 0) {
                graphContainer.innerHTML = '<p style="text-align: center; color: #888; padding: 2rem;">No graph data available</p>';
                return;
            }

            // Create canvas for Chart.js
            graphContainer.innerHTML = '<canvas id="score-chart" style="width: 100%; height: 100%;"></canvas>';
            const canvas = document.getElementById('score-chart');

            const datasets = [];
            let hasData = false;

            topTeams.forEach((team, index) => {
                const solves = team.solves || [];

                if (solves.length > 0) {
                    hasData = true;
                    let cumulativeScore = 0;
                    const dataPoints = [];

                    // Sort solves by date
                    const sortedSolves = [...solves].sort((a, b) =>
                        new Date(a.date) - new Date(b.date)
                    );

                    sortedSolves.forEach(solve => {
                        cumulativeScore += solve.value || 0;
                        dataPoints.push({
                            x: new Date(solve.date),
                            y: cumulativeScore
                        });
                    });

                    datasets.push({
                        label: team.name,
                        data: dataPoints,
                        borderColor: chartColors[index % chartColors.length],
                        backgroundColor: chartColors[index % chartColors.length] + '40',
                        tension: 0.2,
                        fill: false,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        borderWidth: 2
                    });
                }
            });

            if (!hasData) {
                graphContainer.innerHTML = '<p style="text-align: center; color: #888; padding: 2rem;">No solve data to display</p>';
                return;
            }

            if (scoreChart) {
                scoreChart.destroy();
            }

            scoreChart = new Chart(canvas, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                tooltipFormat: 'MMM d, HH:mm'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#888'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#888'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ccc',
                                usePointStyle: true,
                                padding: 15,
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(10, 10, 15, 0.95)',
                            titleColor: '#00d9ff',
                            bodyColor: '#fff',
                            borderColor: '#00d9ff',
                            borderWidth: 1,
                            padding: 12
                        }
                    }
                }
            });
        }

        function renderScoreboard() {
            scoreboardBody.innerHTML = '';

            if (standings.length === 0) {
                scoreboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 2rem; color: #888;">No teams on scoreboard yet</td></tr>';
                return;
            }

            standings.forEach((entry, index) => {
                const row = document.createElement('tr');

                let rankStyle = '';
                let rankIcon = '';
                if (index === 0) {
                    rankStyle = 'color: #ffd700;';
                    rankIcon = 'ðŸ¥‡ ';
                } else if (index === 1) {
                    rankStyle = 'color: #c0c0c0;';
                    rankIcon = 'ðŸ¥ˆ ';
                } else if (index === 2) {
                    rankStyle = 'color: #cd7f32;';
                    rankIcon = 'ðŸ¥‰ ';
                }

                const mode = '{{ get_config("user_mode") }}';
                const profileUrl = mode === 'teams' ? `/teams/${entry.account_id}` : `/users/${entry.account_id}`;

                row.innerHTML = `
                    <td style="padding: 1rem; ${rankStyle} font-weight: 600;">
                        ${rankIcon}${index + 1}
                    </td>
                    <td style="padding: 1rem;">
                        <a href="${profileUrl}" style="color: #00d9ff; text-decoration: none;">
                            ${entry.name}
                        </a>
                    </td>
                    <td style="padding: 1rem; text-align: right; font-weight: 600; color: #b026ff;">
                        ${entry.score}
                    </td>
                `;

                // Hover effect
                row.style.transition = 'background 0.2s';
                row.addEventListener('mouseenter', () => row.style.background = 'rgba(0, 217, 255, 0.1)');
                row.addEventListener('mouseleave', () => row.style.background = 'transparent');

                scoreboardBody.appendChild(row);
            });
        }

        async function updateStats() {
            try {
                const chalResp = await fetch('/api/v1/challenges');
                const chalData = await chalResp.json();
                if (chalData.success) {
                    document.getElementById('total-challenges').textContent = chalData.data.length;
                }

                document.getElementById('total-teams').textContent = standings.length;

                // Calculate total solves
                let totalSolves = 0;
                standings.forEach(team => {
                    if (team.solves) {
                        totalSolves += team.solves.length;
                    }
                });
                document.getElementById('total-solves').textContent = totalSolves || standings.length;

            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        // Auto-refresh every 60 seconds
        setInterval(fetchScoreboard, 60000);

        // Initialize
        fetchScoreboard();
    })();
</script>
{% endblock %}